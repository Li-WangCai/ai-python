- [graphic learning git, great website](https://learngitbranching.js.org/)
- 基本操作
	- ![git文件结构.webp](../assets/git文件结构_1766228179650_0.webp)
	-
	-
- 高级操作
	- ![git结构.jpeg](../assets/git结构_1766228502261_0.jpeg)
	- [[local (git)]]:git的本地文件，本地git文件包含[[workspace]],[[stage]],[[stash]] local [[repository]], 使用[[git fetch]]会从服务器拉回一个分支并存在本地 [[repository]] 的副本，本地操作是用origin/master 类似的名字来引用，origin表示服务器端
	- [[git log]]：查看提交信息，hash和别名
	- [[HEAD]] 可以指向git当前的工作区里的节点。如果是[[git checkout]] BranchName的，就是指向当前分支,可以作为当前分支别名，如果是[[git checkout]] Hashcode,就是指向某个节点。如果HEAD不是某分子的最新节点，就不要在上面提交。一般推荐在该节点新建分支以后再提交
	- [[^]]当前节点的上一个节点如 master^^表示当前节点前两个节点,[[~]]4 表示 4个^
	- [[git clone]]
	- [[git add]]
	- [[git diff]]
	- [[git checkout]] A:  移动到A 分支最新节点（将该节点拉入[[workspace]]）。+a将指定节点a拉入[[workspace]]
	- [[git commit]]
	- [[git reset]] node: 将[[HEAD]]移到node，但是这个命令只是更改本地历史，不能影响[[remote]]
	- [[git revert]]+node在[[HEAD]]后建立一个新节点（node的拷贝），这个操作可以影响[[remote]]
	- [[git fetch]] 将[[remote]]上的版本,例如main拉到本地的 [[repository]]里的一个副本origin/main（没有明确画出来）
	- [[git branch]] 在当前节点创造一个新分支，不创造新节点
	- [[git merge]] BranchName 将Branchname 分支合并到当前[[workspace]]中的分支。git自动合并不同分支中的更改，并将有冲突的更改提交操作者决定。merge的对象可以是分支，可以是某次提交(哈希码），可以指定合并策略
	- [[git rebase]] master 先找当前[[workspace]]中的分支(例如a->b->c->d->e)和master分支(例如a->f->g(master))的共同祖先a，然后把当前分支相对于a的变化全部应用到master分支的最新提交，并在master后面创建新节点，也就是把master分支变成a->f->g->g+(b-a)->g+(c-a)->g+(d-a)->g+(e-a)
	- [[git cherry-pick]] a1 a2, 将a1,a2两个节点的提交依次加到HEAD之后，形成两个新的节点
	-
	-
- 推荐操作
	- 基本操作
		- 本地空白的时候，用[[git clone]]把[[remote]]上的 [[repository]]整体克隆到本地
		- 在[[workspace]]中工作，通过[[git diff]]看作了哪些改动，如果满意就[[git add]] 到[[stage]]。如果不满意就[[git checkout]] 退回[[stage]]中的版本
		- 完成一个fix或feature之后，通过上一步的检查([[git diff]],[[git add]])，满意就把[[stage]]通过[[git commit]]提交到本地[[repository]]，如果不满意，就[[git reset]]将 [[repository]]中早期版本替换到[[stage]]中当前的版本。
		- 一天结束以后，将本地 [[repository]]中的版本推到[[remote]]
	- 多分支操作
		- 所有更改(feature和fix)都是先创建新分支，多次提交完成更改以后再把新分支和主分支合并。具体
			- 先在本地 [[repository]]上建立分支[[git branch]] BranchName, 将 [[workspace]] 切换到新分支[[git checkout]] BranchName。或者用一个命令[[git checkout -b]] BanchName
			- 更改后[[git add]]+[[git commit]](或者[[git commit -a]])提交更改。更改全部完成以后通过[[git merge]]或者[[git rebase]]或者 [[git cherry-pick]] 将更改合并到主分支[[master]]
			- 使用[[git rebase]]的好处是得到一个单一线性的主分支，而不会是像[[git merge]]一样是一团蜘蛛网
	- debug
		- 创建一个debug分支，然后再分支中添加各种debug信息，debug成功以后，使用[[git rebase]] -i或者 [[git cherry-pick]] 选择那些有用的修改合并到master
	- 修改古代的节点，并且让该修改影响后续的版本
		- [[git rebase]] -i 把古代节点a移到最晚节点，用[[git commit --amend]]修改a（但不创建新节点），然后再用[[git rebase]] -i 把顺序调回原样。注意rebase是把每次提交的delta都从新应用一遍，所以调回原来顺序以后，a之后所有的更改都是在新的a的基础上该得，这就实现了目标
		-
	-