- [graphic learning git, great website](https://learngitbranching.js.org/)
- 基本操作
	- ![git文件结构.webp](../assets/git文件结构_1766228179650_0.webp)
	-
	-
- 高级操作
	- ![git结构.jpeg](../assets/git结构_1766228502261_0.jpeg)
	- [[git clone]]
	- [[git add]]
	- [[git diff]]
	- [[git checkout]] branchname  移动到branchname 分支最新节点（将该节点拉入[[workspace]]）。+nodeHash将指定节点拉入[[workspace]]
	- [[git commit]]
	- [[git reset]] +node 将[[HEAD]]移到node，但是这个命令只是更改本地历史，不能影响[[remote]]
	- [[git revert]]+node在[[HEAD]]后建立一个新节点（node的拷贝），这个操作可以影响[[remote]]
	- [[git fetch]] 将[[remote]]上的版本,例如main拉到本地的 [[repository]]里的一个副本origin/main（没有明确画出来）
	- [[git branch]] 在当前节点创造一个新分支，不创造新节点
	- [[git merge]] BranchName 将Branchname 分支合并到当前[[workspace]]中的分支。git自动合并不同分支中的更改，并将有冲突的更改提交操作者决定。merge的对象可以是分支，可以是某次提交(哈希码），可以指定合并策略
	- [[git rebase]] master 先找当前[[workspace]]中的分支(例如a->b->c->d->e)和master分支(例如a->f->g(master))的共同祖先a，然后把当前分支相对于a的变化全部应用到master分支的最新提交，并在master后面创建新节点，也就是把master分支变成a->f->g->g+(b-a)->g+(c-a)->g+(d-a)->g+(e-a)
	- [[git cherry-pick]] a1 a2, 将a1,a2两个节点的提交依次加到HEAD之后，形成两个新的节点
	- [[HEAD]] 可以指向git当前的工作区里的节点。如果是[[git checkout]] BranchName的，就是指向当前分支,可以作为当前分支别名，如果是[[git checkout]] Hashcode,就是指向某个节点。如果HEAD不是某分子的最新节点，就不要在上面提交。
	- [[^]]当前节点的上一个节点如 master^^表示当前节点前两个节点,[[~]]4 表示 4个^
	-
	-
- 推荐操作
	- 基本操作
		- 本地空白的时候，用[[git clone]]把[[remote]]上的 [[repository]]整体克隆到本地
		- 在[[workspace]]中工作，通过[[git diff]]看作了哪些改动，如果满意就[[git add]] 到[[stage]]。如果不满意就[[git checkout]]
		- 完成一个fix或feature之后，通过上一步的检查([[git diff]],[[git add]])，满意就把[[stage]]通过[[git commit]]提交到本地[[repository]]，如果不满意，就[[git reset]]将 [[repository]]中早期版本替换到[[stage]]中当前的版本。
		- 一天结束以后，将本地 [[repository]]中的版本推到[[remote]]
	- 多分支操作
		- 所有更改(feature和fix)都是先创建新分支，多次提交完成更改以后再把新分支和主分支合并。具体
			- 先在本地 [[repository]]上建立分支[[git branch]] BranchName, 将 [[workspace]] 切换到新分支[[git checkout]] BranchName。或者用一个命令[[git checkout -b]] BanchName
			- 更改后[[git add]]+[[git commit]](或者[[git commit -a]])提交更改。更改全部完成以后通过[[git merge]]或者[[git rebase]] 将更改合并到主分支[[master]]
			-
	-